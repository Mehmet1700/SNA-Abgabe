---
title: "Social Network Analysis about the subreddit Event /r/Place2023"
author: "Mehmet Karaca"
date: "27.10.2023"
output:
  pdf_document: 
    toc: yes
    fig_width: 7
    fig_height: 7
    keep_tex: true
  html_document: 
    toc: yes
    toc_float: true
    fig_width: 8
    fig_height: 8
editor_options:
  markdown:
    wrap: sentence
---

<br><br> <br><br><br>

# Einleitung {#sec-einleitung}

## Forschungsfragen: {#sec-forschungsfragen}

## Verwendete Librarys {#sec-verwendete-librarys}



#Installieren der benötigten Packages
install.packages("tidyverse")
install.packages("igraph")
install.packages("ggraph")
install.packages("ggplot2")
install.packages("igraphdata")

#Laden der benötigten Packages
library(tidyverse)
library(igraph)
library(ggraph)
library(ggplot2)
library(igraphdata)

## Datenaufbereitung

Python Datenaufbereitugn erklären

# Datenanalyse und Auswertung {#sec-datenanalyse-und-auswertung}

## Erster Überblick über den Datensatz


```{r}
#Laden der Daten von  /Users/karaca/src/Social_Network_Analysis/Datensatz/2023_place_canvas_20072023.csv
data <- read.csv("Datensatz/2023_place_canvas_20072023.csv", sep = ",")

#csv Datei in ein Dataframe umwandeln
data <- as.data.frame(data)

#Anzeigen der ersten 6 Zeilen
head(data)

#Anzeigen der Struktur der Daten
str(data)

```

```{r}
#install.packages("igraph")
library(igraph)

# Tidyverse ist eine Sammlung von Tools für die Transformation und Visualisierung von Daten, z. B. dplyr, ggplot2, tidyr etc.
#install.packages("tidyverse")
library(tidyverse)

#install.packages(ggplot2)
#library(ggplot2)

#install.packages("dplyr")
#library(dplyr)
```



Da der Datensatz geladen worden ist, möchten wir diesen analysieren. Hierfür müssen wir uns einen Überblick der Daten machen
```{r}
#Zuerst lassen wir uns den höchsten und niedrigsten Wert von timestamp anzeigen
max(data$timestamp)
min(data$timestamp)

#Als nächstes schauen wir uns an, wie viele einzigartige Werte es in der Spalte user gibt. 
#Dies gibt uns die Anzahl an Usern an, da manche User mehrere Einträge haben.
length(unique(data$user))
```

Der Datensatz wurde im Zeitraum von 13:00:26 bis 15:59:59 aufgenommen. In diesem Zeitraum haben 739675 User insgesamt 2411941 Pixel gesetzt. 
Die Pixel Color wurde als int Wert gespeichert, durch die Vorverarbeitung des Datensatzes. Die Zahlen haben einen bestimmten Schlüssel für die Farben.
Tabelle der Farben
rot = #ff4500 = 1
orange = #ffa800 = 2
gelb = #ffd635  = 3
grün = #00a368 = 4
blau = #3690ea = 5
lila = #b44ac0 = 6
schwarz = #000000 = 7
weiß = #ffffff = 8
```{r}
#Diese Farben nutzen wir um einene Farbzuordnungstabelle zu erstellen
farbzuordnung <- c("#ff4500", "#ffa800", "#ffd635", "#00a368", "#3690ea", "#b44ac0", 
"#000000", "#ffffff")
```

Als nächstes zeigen wir uns die maximal und minmalwerte von x und y anzeigen, um einen Eindruck des Koordinatensystems zu bekommen.
```{r}
max(data$x)
min(data$x)
max(data$y)
min(data$y)
```
Das Koordinatensystem erstreckt sich von -500 bis 499 entlang sowohl der X-Achse als auch der Y-Achse.
Als ersten Schritt wollen wir die Daten mit einem Plot visualisieren, um einen Eindruck der Daten zu bekommen.
Hierfür erstellen wir ein Subset, welches nur aus den Koordinatenpaaren besteht.
```{r}
#Erstelle einen Subset, welcher nur aus den Koordinatenpaaren besteht
Koordinaten_subset_x_und_y <- data[,c("x", "y")]

#Diesen Subset wollen wir uns anschauen und plotten diesen in einem Scatterplot.
plot(Koordinaten_subset_x_und_y$x, Koordinaten_subset_x_und_y$y, xlab = "X-Achse", ylab = "Y-Achse")
```
<br> <br>

An dem Plot erkennt man, das beinahe alle Koordinaten mit einem pixel belegt worden sind. Es gibt nur vereinzelte Ausnahmen, die nicht belegt worden sind. 
Aus dem Plot können keine tiefergehenden Erkenntnisse gezogen werden. Daher soll im nächsten Schritt die Punkte farbig visualisiert werden, um bestimmte Muster erkennen zu können.
Hierzu erstellen wir einen neuen Subset, welcher aus den Koordinatenpaaren und dem pixelcolor besteht.
Diesen subset wollen wir uns anschauen und plotten diesen auf einem Scatterplot mit der Farbe des pixel_color.
Die Farben sind in der Tabelle der Farben oben beschrieben.
```{r}
#Erstellen eines neuen Subsets, welches aus den Koordinatenpaaren und dem pixelcolor besteht
Koordinaten_subset_x_y_pixelcolor <- data.frame(x=data$x, y=data$y, pixel_color=data$pixel_color)

#Diesen Subset wollen wir uns anschauen und plotten diesen auf einem Scatterplot mit der Farbe des pixelcolors
plot(Koordinaten_subset_x_y_pixelcolor$x, Koordinaten_subset_x_y_pixelcolor$y, 
col = farbzuordnung[Koordinaten_subset_x_y_pixelcolor$pixel_color] ,pch=15, xlab = "X-Achse", ylab = "Y-Achse")
```
Durch diese Darstellung ist nun zu erkennen, dass es bestimmte Farbmuster gibt.
Beispielsweise sind erste Flaggen zu erkennen wie die Französische (links), die Deutsche (links unten), türkische, indische, italienische
Allerdings haben wir ein Problem bei dieser Visualisierung, da viele Punkte doppelt vorkommen. Dies liegt daran, dass viele User mehrere Pixel gesetzt haben.
Deswegen möchten wir nur die letzten Pixel setzen lassen. Hierfür erstellen wir einen neuen Subset. In diesem subset gibt es keine doppelten Koordinatenpaare.

```{r}
# Entfernen von doppelten Koordinatenpaaren, um nur die letzten Pixel zu behalten
Koordinaten_subset_eindeutig <- 
Koordinaten_subset_x_y_pixelcolor[!duplicated(Koordinaten_subset_x_y_pixelcolor[, c("x", "y")], 
fromLast = TRUE), ]

# Plot der eindeutigen Koordinatenpaare mit der Farbe des letzten pixel_color
plot(Koordinaten_subset_eindeutig$x, Koordinaten_subset_eindeutig$y, 
col = farbzuordnung[Koordinaten_subset_eindeutig$pixel_color], pch = 15, xlab = "X-Achse", ylab = "Y-Achse")
```
Die Genauigkeit und Präzision der Grafik ist nun deutlich besser. Es sind keine doppelten Koordinatenpaare mehr vorhanden.
Allerdings ist dies noch nicht perfekt. Beim ausprobieren mit ggplot2 hat sich gezeigt, dass bei der Verwendung von ggplot2 die Grafik noch präziser wird.
Daher wird im nächsten Schritt die Grafik mit ggplot2 geplottet.
```{r}
#Plotten der Grafik in ggplot
ggplot(Koordinaten_subset_eindeutig, aes(x, y, col = farbzuordnung[pixel_color])) +
  geom_point(shape = 15, size = 0.4) +
  scale_color_identity() +
  theme_minimal() +
  labs(title = "Koordinatenpaare mit Farbe", x = "X-Achse", y = "Y-Achse", col = "Farbe")
```

<br> <br>



Diese Darstellung ist die präzisteste Darstellung, die wir erstellen konnten. Es ist zu erkennen, dass die Flaggen deutlicher zu erkennen sind.
Außerdem sind Sätze, Wörter und Logos zu erkennen. Aber auch Andeutung von Bildern wie z.B. ein blauer Elefant und ein "Pikachu" nut Sonnenbrille (Ein Pokemon aus dem gleichnamigen Spiel) sind der unteren rechten Ecke ist zu erkennen.
Nun möchten wir den zeitlichen Verlauf der Pixel setzen lassen. Diesen möchten wir in Form eines gifs animieren, wie es in der Vorlesung gezeigt worden ist.
Hierfür erstellen wir einen neuen Subset, welcher zusätzlich noch die Spalte timestamp enthält.
```{r}
#Erstellen eines neuen Subsets, welches aus den Koordinatenpaaren, dem pixelcolor und dem timestamp besteht
Koordinaten_subset_x_y_pixelcolor_timestamp <- data.frame(x=data$x, y=data$y, pixel_color=data$pixel_color, timestamp=data$timestamp)

#Der Subset wird nach dem timestamp sortiert und bekommt einen Index mit 1 beginnend zugewiesen
Koordinaten_subset_x_y_pixelcolor_timestamp <- Koordinaten_subset_x_y_pixelcolor_timestamp[order(Koordinaten_subset_x_y_pixelcolor_timestamp$timestamp),]
Koordinaten_subset_x_y_pixelcolor_timestamp$index <- seq.int(nrow(Koordinaten_subset_x_y_pixelcolor_timestamp))

#Der subset wird als Grafik in ggplot dargestellt, um diese später als gif zu animieren
Koordinaten_subset_x_y_pixelcolor_timestamp_grafik <- ggplot(Koordinaten_subset_x_y_pixelcolor_timestamp, aes(x, y, col = farbzuordnung[pixel_color])) +
  geom_point(shape = 15, size = 0.5) +
  scale_color_identity() +
  theme_minimal() +
  labs(title = "Zeitlicher Verlauf der Pixel", x = "X-Achse", y = "Y-Achse", col = "Farbe")

#Anzeigen der Grafik
Koordinaten_subset_x_y_pixelcolor_timestamp_grafik
```
```{r}
#Wir importieren Biblotheken, welche uns beim erstellen des gifs helfen.

#install.packages("gganimate")
library(gganimate)

#install.packages("gifski")
library(gifski)

library(gapminder)

#install.packages("ggplot2")
library(ggplot2)

```

Da wir diese nun importiert haben, können wir das gif erstellen.
Aus der Grafik Koordinaten_subset_x_y_pixelcolor_timestamp_grafik wird ein gif erstellt
Hierzu wird nacheinander in Reihenfolge des Index angezeigt. 
Nach dem ein Pixel gesetzt worden ist, wird der Index um 1 erhöht und der nächste Pixel wird gesetzt.
Dies wird solange wiederholt, bis alle Pixel gesetzt worden sind.
Dieser Prozess wird in 200 Frames mit einer Framerate von 5 fps dargestellt.
Kein Pixel darf nach dem setzen verschwinden oder sich bewegen, sondern bleibt bis zum Ende

```{r}
#Erstellen des gifs.
#Animation <- animate(  Koordinaten_subset_x_y_pixelcolor_timestamp_grafik +
#    transition_manual(index) + ease_aes('linear') + 
#     view_follow(fixed_x = TRUE, fixed_y = TRUE),
#  nframes = 200, fps = 5, width = 800, height = 600)


#Speichern des gifs.
#anim_save("Animation.gif", Animation)

#Da die Darstellung eines beweglichen gifs in einem PDF-Dokument schwierig ist
# und aus Performance Gründen, wurde die Funktion des Gif erstellens auskommentiert,
# aber die gifs ist in der Abgabe beigefügt.
```

Diese Darstellung gibt uns sehr schön den Verlauf des Prozesses dar. Zu Beginn der Veranstaltung gibt 
es gewisse Bereiche, welche sehr schnell gefüllt worden sind.
Diese Bereiche wurden von den dementsprechenden Ländergruppen (z.B. Deutschland, Frankreich, Türkei) 
versucht zu füllen, sodass die Flagge des Landes entsteht. Im weiteren Verlauf des Prozesses wurden
die Länderflaggen immer weiter ausgebaut und es wurden neue Länderflaggen hinzugefügt.Das Bild 
der jeweiligen Länder wurde deutlicher und deutlicher.

Um weitere Erkenntnisse zu ziehen, soll die Quantität untersucht werden. Hierzu soll herausgefunden 
werden, welche Bereche am meisten Pixel gesetzt bekommen haben. Es soll eine Heatmap erstelt werden,
welcher die Bereiche mit den meisten Färbungen anzeigt. Hierfür erstellen wir einen neuen Subset,
welcher aus den Koordinatenpaaren besteht.
```{r}
#Erstellen eines neuen Subsets, welches aus den Koordinatenpaaren besteht
Koordinaten_subset_x_y_heatmap <- data.frame(x=data$x, y=data$y)

#Füge eine neue Spalte hinzu, welcher die Koordinatenpaare zusammenfasst
Koordinaten_subset_x_y_heatmap <- transform(Koordinaten_subset_x_y_heatmap, x_y = paste(x, y, sep = "_"))

#Die doppelten Werte von x_y werden zusammengefasst und gezählt und in der Spalte count gespeichert und anschließend 
#nach der Anzahl der Koordinatenpaare absteigend sortiert
Koordinaten_subset_x_y_heatmap <- Koordinaten_subset_x_y_heatmap %>% group_by(x_y) %>% summarise(count = n()) %>% arrange(desc(count))

#Nun sollen doppelte Koordinatenpaare x_y entfernt werden, um nur die eindeutigen Koordinatenpaare zu behalten
Koordinaten_subset_x_y_heatmap <- Koordinaten_subset_x_y_heatmap[!duplicated(Koordinaten_subset_x_y_heatmap$x_y), ]

#Zeige die ersten 5 Zeilen des Subsets an
head(Koordinaten_subset_x_y_heatmap)

# Zeige den größten und kleinsten Wert von count an
max_count <- max(Koordinaten_subset_x_y_heatmap$count)
min_count <- min(Koordinaten_subset_x_y_heatmap$count)

# Erstelle die Dichtefunktion
density_function <- ecdf(Koordinaten_subset_x_y_heatmap$count)

# Plotte die Dichtefunktion
plot(density_function, xlim=c(0, 2000), ylim=c(0, 1), 
     xlab="Anzahl der Koordinatenpaare", 
     ylab="Kumulierte Wahrscheinlichkeit", 
     main="Kumulierte Dichtefunktion der Koordinatenpaare")
```
Die kumulierte Dichtefunktion der koordinatenpaare wurde benötigt, da vorher nicht ersichtlich war, wie die Verteilung der Koordinatenpaare ist.
Ohne diese Erkenntnis war es durchaus schwierig eine passende Farbpalette zu erstellen, da die Verteilung sehr ungleichmäßig ist.
Diese ungleichmäßige Verteilung mit einer gleichmäßigen Farbpalette darzustellen, würde zu einer falschen Darstellung führen.
Beim ausprobieren mit einer gleichmäßigen Farbpalette war die Visualisierung nicht aussagekräftig.
Diese Erkenntnis hat sich im Verlauf der Untersuchung herausgestellt, weshalb Anpassungen vorgenommen wurden.
Nun ist es möglich eine aussagekräftige Heatmap zu erstellen.
```{r}
#Erstellen einer Tabelle, welche die Häufigkeit der Koordinatenpaare zählt
Koordinaten_subset_x_y_heatmap_tabelle <- data.frame(x=data$x, y=data$y)

# Zähle die Häufigkeit der Koordinatenpaare und erstelle eine neue Tabelle
häufigkeit_tabelle <- as.data.frame(table(Koordinaten_subset_x_y_heatmap_tabelle))

# Benenne die Spalten um
colnames(häufigkeit_tabelle) <- c("X", "Y", "Anzahl")

#Füge eine neue Spalte hinzu, welche den Koordinatenpaare Farben zuweist, je nach Anzahl der Koordinatenpaare
#Die Farbbereiche werden durch eine passende Auswahl definiert.
häufigkeit_tabelle$Farbe <- ifelse(häufigkeit_tabelle$Anzahl == 0, "white",
                                   ifelse(häufigkeit_tabelle$Anzahl < 10, "#b44ac0",
                                          ifelse(häufigkeit_tabelle$Anzahl < 50, "#3690ea",
                                                        ifelse(häufigkeit_tabelle$Anzahl < 350, "#ffa800", "red"))))

# Zeige einen Ausschnitt der Tabelle an zum testen
#print(head(häufigkeit_tabelle))

#Anzahl der Zeilen der Tabelle
#nrow(häufigkeit_tabelle)

#Nun erstellen wir einen Plot, welcher die X-Achse und Y-Achse der Koordinatenpaare mit ihrer Farbe darstellt.
Koordinaten_subset_x_y_heatmap_tabelle_grafik <- ggplot(häufigkeit_tabelle, aes(X, Y, col = Farbe)) +
  geom_point(shape = 15, size = 0.5) +
  scale_color_manual(values = as.character(häufigkeit_tabelle$Farbe)) +
  theme_minimal() +
  theme(axis.title = element_blank(), axis.text = element_blank(),
        axis.line = element_blank(), axis.ticks = element_blank()) +
  labs(title = "Heatmap von der Anzahl der Setzungen", col = "Farbe")

#Anzeigen der Grafik
Koordinaten_subset_x_y_heatmap_tabelle_grafik

```

Durch die Heatmap erkennt man sehr schön, welche Bereiche am meisten Pixel gesetzt bekommen haben.
Die roten Bereiche wurden relativ oft gesetzt. Die Anzahl dieser bereiche ist relativ wenig.
Es gibt Anhäufungen in den Ecken des Koordinatensystems mit Ausnahme der rechten unteren Ecke. 
Außerdem gibt es in der Mitte des Koordinatensystems verteile kleinere Anhäufungen von Pixeln.
In diesen roten Bereichen kann es durchaus sein, dass die Teilnehmer an der Veranstaltungen sich gegenseitig überboten haben.
Die Annahme, dass die roten Bereiche entstanden sind, um bestimmte Bilder zu erzeugen und gemeinsam zu erstellen, kann wiederlegt werden durch die Betrachtung der blauen Bereiche der Heatmap.
In den blauen Bereichen sind zusammenhängende Bereiche und Muster zu erkennen. Diese Bereiche sind relativ groß und wurde daher nicht versucht zu zerstören oder zu überpixel.
Es sind vereinzelt auch Buchstaben erkenntlich, welche in den blauen Bereichen entstanden sind.
Besonders auffällig ist der vertikale blaue Streifen auf der linken Seite der Heatmap. Außerdem ist ein weiterer horizontaler blauer Streifen in der unteren Seite der Heatmap zu erkennen.

## Untersuchung der Hauptakteure (Stehen die Hauptakteure in Beziehung zu einandner?)
Da nun ein grober Überblick der gesamten Daten und des Koordinatensystems vorhanden ist, soll nun untersucht werden, welche User die Hauptakteure sind.
Hierfür erstellen wir einen neuen Subset, welcher aus den Koordinatenpaaren, dem pixelcolor, dem timestamp und dem user besteht.
Diesen Subset filtern wir nach den Top 20 Usern, welche die meisten Pixel gesetzt haben.
```{r}
#Erstellen eines neuen Subsets, welches aus den Koordinatenpaaren, dem pixelcolor, dem timestamp und dem user besteht
Top20User <- data.frame(x=data$x, y=data$y, pixel_color=data$pixel_color, timestamp=data$timestamp, user=data$user)

#Filtern des Subsets nach den Top 20 Usern, welche die meisten Pixel gesetzt haben
Top20User <- Top20User %>% group_by(user) %>% summarise(count = n()) %>% arrange(desc(count)) %>% head(20)

#Anzeigen der Top20 User
print(Top20User)
```

Die Beziehungen der Top20 User möchten wir näher untersuchen, um zu schauen, ob es bestimmte Beziehungen zwischen den Usern gibt.
Außerdem soll die Präferenz der Farben der Top20 User untersucht werden.
Hierfür erstellen wir einen neuen Subset, welcher aus den Koordinatenpaaren, dem pixelcolor, dem timestamp und dem user besteht.
Diesen Subset filtern wir nach den Top 20 Usern, welche die meisten Pixel gesetzt haben.
Für die Untersuchung wird die library iGraph genutzt und wandeln den Dataframe in einen iGraph-Objekt.

```{r}
```



